# 信息的表示和处理
## 进制转换
一个字节由8位组成， 在二进制中， 其值域是`00000000 - 11111111`, 十进制中是`0 - 255` 十六进制中是`00 - 0xFF`;

十六进制数字 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
---| --- | --- | --- | --- | --- | --- | --- | ---
十进制值 | 0 | 1 | 2| 3 | 4 | 5 | 6 | 7
二进制值 |0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111
十六进制数字 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15
十进制值 | 8 | 9 | A | B | C | D | E | F
二进制值 |1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111

### 技巧
* 记住十六进制数字A、C、F和相对应的十进制(10, 12, 15)
* 二进制11 相当于 +3， `1000 -> 8`, 那么`1011 -> 8 + 3 = 11 = B`
* 二进制到10进制的转换： `binary -> hex -> decimal`， 因为二进制先到16进制可以直接观察得到， 再由16进制到10进制的话， 除起来会比较快
* 二进制和十六进制 `-> `十进制， 需要使用乘法和加法， 十进制到二进制或者十六进制， 需要使用短除法。 ~~十六进制取余数的时候， 不取最后一次的商~~（十六进制也需要）， 二进制则需要。
* `2^3 = 8`, `2^5 = 32`,  `2^8 = 256`, `2^10 = 1024`

### 2.2 补码编码
* 32位的机器， 表示其数值编码由`32 / 4 = 8`个16进制数组成， 无符号的情况下， 其最大值为`2^8 - 1`, 同理， 64位的则由`64 / 4 = 16`个16进制数组成， 无符号最大为`2^16 - 1`
* 无符号和有符号位的转换 U2T, T2U
  * 如果待转换的值**大于0**, 则转换后的值即为原值
  * 如果小于0(w表示字长)
    * 无符号 -> 有符号： `原值 - 2^w`
    * 有符号 -> 无符号： `原值 + 2^w`
  * 可以这样理解， 因为无符号要变成有符号， 如果是+2^w的话， 那么依然是个整数， 所以应该减2^w
  * 实际上是因为， 对于补码来说， 最高位是符号位， 对于无符号数来说， 最高位是权重位， 所以无符号到有符号的转化， 实际上就涉及到了最高位的职能变化， 而最高位的表示则为2^(w - 1), 所以使用这个来相减或者相加， 即可得到转换后的值了。
  * 具体的推导过程看书（P45）。
